<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Test: Announcement Uniqueness</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f0fdfa;
        }
        
        h1 {
            color: #0891b2;
            border-bottom: 3px solid #f97316;
            padding-bottom: 10px;
        }
        
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-result {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid;
        }
        
        .test-result.pass {
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }
        
        .test-result.fail {
            background: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
        }
        
        .test-result.running {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }
        
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .test-details {
            font-size: 0.9em;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }
        
        .summary {
            background: #0891b2;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        
        .summary.fail {
            background: #ef4444;
        }
        
        .property-info {
            background: #fff7ed;
            border-left: 4px solid #f97316;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .property-info h3 {
            margin-top: 0;
            color: #ea580c;
        }
        
        code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <h1>üß™ Property-Based Test: Announcement Uniqueness</h1>
    
    <div class="property-info">
        <h3>Property 4: Announcement Uniqueness</h3>
        <p><strong>Feature:</strong> portfolio-improvements</p>
        <p><strong>Validates:</strong> Requirements 3.2</p>
        <p><strong>Property Statement:</strong> <em>For any</em> set of announcements, each announcement should have unique id, title, and content.</p>
    </div>
    
    <div id="test-results"></div>
    
    <div id="summary" class="summary" style="display: none;">
        <h2 id="summary-text"></h2>
        <p id="summary-details"></p>
    </div>

    <script src="../js/announcements.js"></script>
    <script>
        // Simple property-based testing framework
        class PropertyTest {
            constructor() {
                this.results = [];
                this.numRuns = 100;
            }
            
            assert(testName, propertyFn, options = {}) {
                const runs = options.numRuns || this.numRuns;
                
                try {
                    for (let i = 0; i < runs; i++) {
                        propertyFn(i);
                    }
                    this.results.push({ name: testName, passed: true, runs });
                    return true;
                } catch (error) {
                    this.results.push({ 
                        name: testName, 
                        passed: false, 
                        error: error.message,
                        runs 
                    });
                    return false;
                }
            }
            
            expect(actual) {
                return {
                    toBe(expected) {
                        if (actual !== expected) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                        }
                    },
                    not: {
                        toBe(expected) {
                            if (actual === expected) {
                                throw new Error(`Expected not to be ${JSON.stringify(expected)}`);
                            }
                        },
                        toContain(item) {
                            if (actual.includes(item)) {
                                throw new Error(`Expected not to contain ${JSON.stringify(item)}`);
                            }
                        }
                    },
                    toMatch(pattern) {
                        if (!pattern.test(actual)) {
                            throw new Error(`Expected ${JSON.stringify(actual)} to match pattern ${pattern}`);
                        }
                    },
                    toBeGreaterThan(expected) {
                        if (actual <= expected) {
                            throw new Error(`Expected ${actual} to be greater than ${expected}`);
                        }
                    },
                    toBeGreaterThanOrEqual(expected) {
                        if (actual < expected) {
                            throw new Error(`Expected ${actual} to be greater than or equal to ${expected}`);
                        }
                    }
                };
            }
        }
        
        // Random data generators
        function randomString(minLength, maxLength) {
            const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result.trim() || 'default';
        }
        
        function randomDate() {
            const start = new Date('2020-01-01');
            const end = new Date('2030-12-31');
            const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
            return date.toISOString().split('T')[0];
        }
        
        function randomTime() {
            const hours = Math.floor(Math.random() * 24);
            const minutes = Math.floor(Math.random() * 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        function generateRandomAnnouncement() {
            return {
                title: randomString(5, 200),
                date: randomDate(),
                time: randomTime(),
                summary: randomString(5, 150),
                content: randomString(10, 1000),
                isActive: Math.random() > 0.5
            };
        }
        
        // Test runner
        async function runTests() {
            const resultsDiv = document.getElementById('test-results');
            const pt = new PropertyTest();
            
            // Test 1: Each announcement in a set has unique IDs
            resultsDiv.innerHTML += createTestResult(
                'Test 1: Each announcement in a set has unique IDs',
                null,
                'Running 100 iterations...'
            );
            
            const test1Passed = pt.assert(
                'Each announcement in a set has unique IDs',
                (iteration) => {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Create manager and add multiple announcements
                    const manager = new AnnouncementManager();
                    const numAnnouncements = Math.floor(Math.random() * 9) + 2; // 2-10 announcements
                    
                    for (let i = 0; i < numAnnouncements; i++) {
                        const announcementData = generateRandomAnnouncement();
                        manager.create(announcementData);
                    }
                    
                    // Get all announcements
                    const allAnnouncements = manager.getAll();
                    
                    // Collect all IDs
                    const ids = allAnnouncements.map(a => a.id);
                    const uniqueIds = new Set(ids);
                    
                    // All IDs must be unique
                    pt.expect(uniqueIds.size).toBe(ids.length);
                    
                    // Each ID should appear exactly once
                    ids.forEach(id => {
                        const count = ids.filter(i => i === id).length;
                        pt.expect(count).toBe(1);
                    });
                }
            );
            
            updateTestResult(0, test1Passed, pt.results[0]);
            
            // Test 2: Each announcement in a set has unique titles
            resultsDiv.innerHTML += createTestResult(
                'Test 2: Each announcement in a set has unique titles',
                null,
                'Running 100 iterations...'
            );
            
            const test2Passed = pt.assert(
                'Each announcement in a set has unique titles',
                (iteration) => {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Create manager and add multiple announcements with unique titles
                    const manager = new AnnouncementManager();
                    const numAnnouncements = Math.floor(Math.random() * 9) + 2; // 2-10 announcements
                    
                    for (let i = 0; i < numAnnouncements; i++) {
                        const announcementData = generateRandomAnnouncement();
                        // Ensure unique title by appending iteration number
                        announcementData.title = `${announcementData.title}_${iteration}_${i}`;
                        manager.create(announcementData);
                    }
                    
                    // Get all announcements
                    const allAnnouncements = manager.getAll();
                    
                    // Collect all titles
                    const titles = allAnnouncements.map(a => a.title);
                    const uniqueTitles = new Set(titles);
                    
                    // All titles must be unique
                    pt.expect(uniqueTitles.size).toBe(titles.length);
                    
                    // Each title should appear exactly once
                    titles.forEach(title => {
                        const count = titles.filter(t => t === title).length;
                        pt.expect(count).toBe(1);
                    });
                }
            );
            
            updateTestResult(1, test2Passed, pt.results[1]);
            
            // Test 3: Each announcement in a set has unique content
            resultsDiv.innerHTML += createTestResult(
                'Test 3: Each announcement in a set has unique content',
                null,
                'Running 100 iterations...'
            );
            
            const test3Passed = pt.assert(
                'Each announcement in a set has unique content',
                (iteration) => {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Create manager and add multiple announcements with unique content
                    const manager = new AnnouncementManager();
                    const numAnnouncements = Math.floor(Math.random() * 9) + 2; // 2-10 announcements
                    
                    for (let i = 0; i < numAnnouncements; i++) {
                        const announcementData = generateRandomAnnouncement();
                        // Ensure unique content by appending iteration number
                        announcementData.content = `${announcementData.content}_${iteration}_${i}`;
                        manager.create(announcementData);
                    }
                    
                    // Get all announcements
                    const allAnnouncements = manager.getAll();
                    
                    // Collect all content
                    const contents = allAnnouncements.map(a => a.content);
                    const uniqueContents = new Set(contents);
                    
                    // All content must be unique
                    pt.expect(uniqueContents.size).toBe(contents.length);
                    
                    // Each content should appear exactly once
                    contents.forEach(content => {
                        const count = contents.filter(c => c === content).length;
                        pt.expect(count).toBe(1);
                    });
                }
            );
            
            updateTestResult(2, test3Passed, pt.results[2]);
            
            // Test 4: Generated IDs are always unique across multiple creations
            resultsDiv.innerHTML += createTestResult(
                'Test 4: Generated IDs are always unique across multiple creations',
                null,
                'Running 100 iterations...'
            );
            
            const test4Passed = pt.assert(
                'Generated IDs are always unique across multiple creations',
                (iteration) => {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Create manager
                    const manager = new AnnouncementManager();
                    const numAnnouncements = Math.floor(Math.random() * 16) + 5; // 5-20 announcements
                    
                    const generatedIds = [];
                    
                    // Create announcements rapidly
                    for (let i = 0; i < numAnnouncements; i++) {
                        const announcementData = generateRandomAnnouncement();
                        const result = manager.create(announcementData);
                        if (result.success) {
                            generatedIds.push(result.data.id);
                        }
                    }
                    
                    // All generated IDs must be unique
                    const uniqueIds = new Set(generatedIds);
                    pt.expect(uniqueIds.size).toBe(generatedIds.length);
                    
                    // Verify no ID appears more than once
                    generatedIds.forEach(id => {
                        const count = generatedIds.filter(gid => gid === id).length;
                        pt.expect(count).toBe(1);
                    });
                }
            );
            
            updateTestResult(3, test4Passed, pt.results[3]);
            
            // Test 5: Even with duplicate data, IDs remain unique
            resultsDiv.innerHTML += createTestResult(
                'Test 5: Even with duplicate data, IDs remain unique',
                null,
                'Running 100 iterations...'
            );
            
            const test5Passed = pt.assert(
                'Even with duplicate data, IDs remain unique',
                (iteration) => {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Create manager
                    const manager = new AnnouncementManager();
                    
                    // Create same announcement data multiple times
                    const announcementData = generateRandomAnnouncement();
                    const numDuplicates = Math.floor(Math.random() * 6) + 2; // 2-7 duplicates
                    
                    const createdIds = [];
                    
                    for (let i = 0; i < numDuplicates; i++) {
                        const result = manager.create(announcementData);
                        if (result.success) {
                            createdIds.push(result.data.id);
                        }
                    }
                    
                    // All IDs must be unique even though data is the same
                    const uniqueIds = new Set(createdIds);
                    pt.expect(uniqueIds.size).toBe(createdIds.length);
                    
                    // Each ID should be different
                    for (let i = 0; i < createdIds.length; i++) {
                        for (let j = i + 1; j < createdIds.length; j++) {
                            pt.expect(createdIds[i]).not.toBe(createdIds[j]);
                        }
                    }
                }
            );
            
            updateTestResult(4, test5Passed, pt.results[4]);
            
            // Show summary
            const totalTests = pt.results.length;
            const passedTests = pt.results.filter(r => r.passed).length;
            showSummary(passedTests === totalTests, passedTests, totalTests);
        }
        
        function createTestResult(name, passed, details) {
            const status = passed === null ? 'running' : (passed ? 'pass' : 'fail');
            const icon = passed === null ? '‚è≥' : (passed ? '‚úÖ' : '‚ùå');
            
            return `
                <div class="test-section">
                    <div class="test-result ${status}">
                        <div class="test-name">${icon} ${name}</div>
                        <div class="test-details">${details}</div>
                    </div>
                </div>
            `;
        }
        
        function updateTestResult(index, passed, result) {
            const sections = document.querySelectorAll('.test-section');
            const section = sections[index];
            const testResult = section.querySelector('.test-result');
            
            testResult.className = `test-result ${passed ? 'pass' : 'fail'}`;
            
            const icon = passed ? '‚úÖ' : '‚ùå';
            const testName = testResult.querySelector('.test-name');
            testName.innerHTML = testName.innerHTML.replace(/^[‚è≥‚úÖ‚ùå]/, icon);
            
            const details = passed 
                ? `PASSED - ${result.runs} iterations completed successfully`
                : `FAILED - ${result.error}`;
            
            testResult.querySelector('.test-details').textContent = details;
        }
        
        function showSummary(allPassed, passed, total) {
            const summaryDiv = document.getElementById('summary');
            const summaryText = document.getElementById('summary-text');
            const summaryDetails = document.getElementById('summary-details');
            
            summaryDiv.style.display = 'block';
            summaryDiv.className = allPassed ? 'summary' : 'summary fail';
            
            if (allPassed) {
                summaryText.textContent = 'üéâ All Tests Passed!';
                summaryDetails.textContent = `${passed} out of ${total} property tests passed`;
            } else {
                summaryText.textContent = '‚ùå Some Tests Failed';
                summaryDetails.textContent = `${passed} out of ${total} property tests passed`;
            }
        }
        
        // Run tests when page loads
        window.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
